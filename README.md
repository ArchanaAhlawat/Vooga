**Vooga**
==========

Vooga provides a game authoring environment for users to create games with custom objects (drawn or uploaded) and custom backgrounds, specify termination or leveling up conditions, give custom attributes and actions to objects, and generate dialogue scenes. Users can save these games in authoring format for future editing, and can also play their own games. Vooga can support role-playing games, scrolling games, tower defense, and turn-based strategy games. Further information about code design and how to use the interface is found below.

**Design Review**
============

### **Overall Design**
At the highest level, the overall program is controlled by SceneController, which has functionality to basically shift the scene in reaction to whatever the user clicks.  For example, first it opens up to a main splash screen stage.  Then, depending on what the user selects, it handles that event by switching the scene.  SceneController contains all the different possible scenes and stores them in a map. These scenes include the welcome screen, game display, game selector, the learn screen, and settings, among others.

Games have an unlimited number of worlds, which can have an unlimited number of layers (at least in engine), and layers contain different game objects, which can contain any number of associated conditions and actions.  Unfortunately, one limitation is that the authoring environment only supports 4 layers per world - background, terrain, main view, and panels.  This decision was made because this number of layers looked best on the UI.

#### Authoring
Authoring begins with FileSelector, which constructs the scene where a user can click on an existing authoring project to work on or create a new one.  The MainAuthoringGUI is the highest level for each authoring project.  It instantiates a lot of important classes such as GameDataHandler, which handles saving and loading data for all projects and between authoring data and engine, AuthoringEnvironmentManager (UI component that handles all sprites that are in the sidebar), SpriteObjectGridToEngineController (a very long name for what is basically a class that formats authoring data to be passed to engine!) and AuthoringController.  AuthoringController instantiates and handles different managers for various components of authoring -- the sprite creator, inventory, cutscenes, dialogue, heads up display, and a map manager.  All these different managers handle the different tabs a user could choose in the authoring environment.  For example, for the main world-creation tab, mapManager stores and updates all the grids/worlds that a user creates, including all the different layers, sprite placements, and backgrounds.  As another example, the sprite creator manager handles the sprite creator tab, where a user can create a sprite, and the sprite is saved (and mapManager gets this updated information about a new user created sprite and displays it in the sidebar sprite tab).  All these different managers, as I mentioned, are instantiated via the AuthoringController, which takes in an instance (the only instance) of AuthoringEnvironmentManager.  This instance of AuthoringEnvironmentManager is then passed into each of the managers.  This is a dependency because there is a certain order that things must be initialized in, but in this way, we allow all the different managers to have access to certain relevant information and pass information between each other if needed.  For instance, this is helpful when a user creates a sprite in the sprite creator tab.  This new custom sprite shows up when the maps tab is opened again, because of AEM.  One really big dependency is that GameDataHandler is passed to a lot of classes in a hidden way... Since AEM is passed to all these managers, classes downstream in the hierarchies of the managers can access the GameDataHandler (GDH) instance via a getter method in AEM.  Unfortunately, this access was a pretty last minute change to get everything to be functional, so we ran out of time to refactor this to encapsulate data handling in GDH more.

This design is not very tied to our chosen game genre - RPGs.  This is because authoring gives the user an environment where the user can define any type of object they want to, give it no, one, or many types of actions and conditions (a lot of combinations are possible because of engine capabilities).  Making everything a game object means that a static object can be a game object with no conditions and actions.  A user can also create cutscenes, include dialogue, trigger cutscenes and dialogue via actions and conditions of game objects, create and heads up displays.  In this way, a user can create virtually any type of game -- platforming games, puzzles, fighting games, and tower defense.  However, turn-based strategy games and real time strategy games would be more difficult to implement.  In authoring (and in engine), we don't really account for time limits on movements.  I think this would not be that difficult to implement, but our UI is not very conducive to creating these types of games easily.

There is nothing technically required to represent any type of game.  A user can manually create all the sprites that they need.  However, if the user wants to use specific images they already have, they just need to have access to them on their laptop and upload them to the authoring environment. 

#### Engine
The core structure of engine is a clear hierarchy that very directly mirrors our game structure discussed at the very top.  An engine controller triggers updates/steps in engine worlds.  GameMaster, the implementation of engine controller, instantiates gameWorlds.  GameWorlds can instantiate and add any number of gameLayers.  GameLayers contain any number of Elements, including GameObjects and inventories. GameObjects contain any number of conditions and actions.  A condition, for example, if the right arrow key is pressed, can trigger any number of actions, such as shifting the gameObject right by 5.  Additionally, gameObjects can contain any number of double variables, string variables, and boolean variables, as well as their associated images or image sequences (animations), x and y coordinates, and orientation.  An example of a boolean variable is "alive," which may be true or false.  To actually trigger changes based on conditions and actions, engine iterates through all possible conditions, and if one of them is true, the gameObject is updated.  The images/animation sequences of objects are based on bounding boxes, which can be drawn and customized by the user.  These bounding boxes are used to handle collisions.

The engine hierarchy is very clearly defined and information is well encapsulated.  

The design, similar to authoring, is not very tied to authoring.  Since authoring design was based on engine design and the concept of game worlds that contain layers that contain game objects, the same analysis of how authoring can handle different types of games applies to engine as well.  The one note is that engine can handle an unlimited number of layers while authoring only handles 4.  This makes it so engine can handle possible more complicated games that have many multiple layers of objects.

#### Player
Player and authoring were very integrated in our team.  Authoring data was converted to engine via the engine exporter class described above.  After de-serializing authoring data, a new engine controller is created using this data.  PlayerManager is the main class the interfaces between authoring data and engine by creating this new engine controller.  It uses GameDataHandler to retrieve de-serialized data.  It passes information back and forth between engine and player (uses GameController) so that only relevant updates are passed and nothing more.  GameDisplay is the class the triggers PlayerManager, since GameDisplay is triggered via the SceneSelector discussed above. 

PlayerManager requires authoring data to be formatted properly and needs to process the updates from engine to be displayed on player.

The design of player is not at all attached to any game.  This is because it essentially acts as a connector for pre-existing authoring data and engine, and just displays updates.

#### Data
Data is handled via GameDataHandler and SpriteObjectGridToEngineController.  GameDataHandler handles serialization and de-serialization for engineController, games created in authoring, and images.  For games created in authoring, it specifically handles the saving and loading of worlds, their associated layers, layers' associated game objects (sprites), and these sprites' associated information (variables, actions, conditions, images).  SpriteObjectGridToEngineController converts authoring data (authoring worlds, layers, and sprites) to engine data (engine worlds, layers, and game objects).  GameDataHandler is handled all throughout authoring and requires the name of the project/game and its location in the local directory.  SOGTEC requires access to all authoring data. 

The design of data handling is not based on any particular genre.  Any game data can be handled with this, if it can be created with worlds, layers, and game objects. 

In data, here is how data is saved: on the user's local directory, a new file for all projects is created.  Within this, each project gets its own directory.  With each project directory, folders for sprites and worlds are created. In the worlds directory, all XML files for worlds are stored (after being serialized).  In the sprites directory, different folders for custom sprites, default sprites, and user created sprites are stored. 

**Two Packages I Did Not Implement**
1. Sprite Sub-package of Engine: This subpackage contains 12 classes that define how images appear and are bounded.  Sprite images have relative bounds as defined by BoundedImage. The AnimationSequence basically iterates through a list of bounded images.  A Positionable defines an image that can be stretched or shrunk (PositionableObject extends Positionable).  Displayable extends Positionable, and there is a DisplayableObject class. A displayable can be placed relative to a positionable.  This allows two images/objects to be connected as one of them moves. 
2. The ActionConditions subpackage of Authoring contains 38 classes that create and control the authoring view of conditions and actions (that can be applied to game objects/sprites).  There are many interfaces that define similar functionality for conditions and actions.  To make how they are used clear: Conditions and actions can open up as separate tabs for every sprite that a user drags onto the grid/world.  Each condition that is defined (from a dropdown of predefined options from engine) can be associated with multiple conditions (also predefined in engine and given in a dropdown).  Every action must be paired with at least one condition, and every condition must be paired with at least one action.  Therefore, similar functionality is needed for both of these.  

I think that the first subpackage I looked at, Sprite in Engine, is more readable.  Both subpackages are documented well, although there are some gaps in the Sprite subpackage where it is unclear what exactly a class is meant to do and how it relates to the other classes in the package.  Even with these gaps, the simple and short methods in each of the Sprite classes make it easy to understand what is being done.  For example, the AnimationSequence class is extremely readable and does exactly what you would think.  It has methods to iterate through a list of bounded images according to some step size.  There is also a getter method for the current image and a check for whether to reset the animation sequence or not.  Each one of these methods is very short - the longest one is 6 lines - and commented, which helps.  

On the other hand, the actions/conditions subpackage is very difficult to parse through and understand.  The sheer size of the actions/conditions subpackage seems unnecessary -- there are many interfaces that seem to only be used once and to be used for a very specific purpose, and there is a lot of repeated code/similarities in structure because of the similar features of actions and conditions frontend and backend code.  As I initially looked at the package, I had no idea where to start because the class names are all very similar and don't indicate some kind of hierarchy.  As an example of non-readable code, it is unclear what the the ActionNameTreeItem class is meant to do, and the methods are all pretty long.  The class name doesn't inform me as to what to expect.  

I think that the sprite subpackage of engine is more encapsulated that the actions/conditions subpackage of authoring.  This is because it is pretty clear from the javadoc comments that, for example, the animationSequence class utilized bounded Images, and that Displayables and Positionables are both types of images that are also boundedImages.  The inheritance hierarchies used in this package help take away repeated code and help create objects that can access some similar information but also store separate information away from other objects.  The main challenge in actions/conditions that creates more hidden dependencies is that actions must be attached to conditions, and that there are a lot of options that a user can click that open up other specific options, and so on.  The conditions tab must have access to different actions that it can trigger, and so this information is passed down.  One other concerning dependency is that in ExistingItemsChoiceBox, it uses a static AuthoringEnvironmentManager to get a list of all existing sprite names... even though sprites can be dynamically changed.  This is definitely not very flexible and is an extremely hidden dependency on AEM and the assumption that a user will not dynamically create sprites after they have started editing an existing sprite. In this way, the sprite subclass of engine is more encapsulated and modular because of the inheritance hierarchy it utilizes. 

After reading my teammates' code, especially engine code, I have learned the importance of leaving really detailed and understandable javadoc comments.  Engine code was so much easier to understand because of javadoc comments that directly explained why a particular class was important and useful, and how it relates to other classes.  Additionally, this project in general as well my experience looking through authoring code versus engine code, I understand more the importance of consciously building modular code instead of just continuously adding more code on top of existing code.  Adding authoring elements would have been much easier if people had initially plotted out the design and potential hierarchies earlier on.

### My Design

Here are the main classes I edited, created or worked on, and debugged: AuthoringEnvironmentManager, AuthoringMapStackPane, DraggableGrid, MainAuthoringGUI, MapManager, SpriteGridHandler, Toolbar, Layer (+ its 4 concrete implemented classes), SpriteObjectGridManager (+ its 5 concrete implemented classes), DisplayPanel, SpritePanels, AuthoringController, GameDataHandler, SpriteDataConverter, LayerDataConverter, MapDataConverter, SpriteSet, SpriteSetImported, and SpriteSetImportedInventory.

For the biggest part I worked on, I worked mostly on GameDataHandler, MapManager, DraggableGrid, LayerDataConverter, and MapDataConverter.  GameDataHandler (GDH) is constructed with a project name, and it automatically creates certain local directories for future worlds and sprites.  MapManager utilizes GDH in order to load up pre-existing worlds if they exist.  MapManager calls GDH.getListOfDraggableGrids(), and if there are worlds in the returned list, it loads these worlds up in the frontend component.  Within GDH, this method essentially goes into the directory for the project defined, and if there are world XML files in there, then it will de-serialized these XML files and create one DraggableGrid for every world there is.  The XML files for worlds contain serialized information for layers and sprites as well.  I updated prior MapManager code to handle these pre-existing worlds and update the number of tabs that display the number of worlds to properly show unique world names that are predefined.  Within the authoring environment, a user can save, load, and import worlds.  To implement this functionality, I added buttons to the front-end authoring GUI component and added event handlers that would trigger MainAuthoringGUI to access information stored via GameDataHandler (ex: saveWorlds(), loadWorlds()).

I also worked on refactoring the authoring flow of information a lot, and described what the flow looks like above.  To continue: there is one SpriteObjectGridManager for every layer in every world.  SpriteObjectGridManager is a superclass, and for every layer, there is a subclass that extends SpriteObjectGridManager.  These classes basically organize the sprites on the grid, and along with SpriteGridHandler, handle clicks and changes to sprites on the grid.  SpritePanels and DisplayPanels are initialized in MapManager and there are unique instances for every world there is.  These create the sidebar environments for sprites that are on the grid. For example, if a sprite is clicked, we will want to see its parameters, etc on the sidebar.

**Two Features that I Implemented**

A user can save, load, and import worlds within the authoring environment.  I added each of these functionalities.  Loading and importing use very similar methods.  For save, when a user clicks the save button, the event handler basically gets triggers MainAuthoringGUI to trigger the saveWorlds() method in GDH.  This method makes sure to remove the currently saved project, if there is one, and then for each world that exists in the authoring environment (aka DraggableGrid, which is used to represent/contain information for each world), serializes it using MapDataConverter, which takes in a DraggableGrid in its constructor.  Within MapDataConverter, each layer that is contained in the DraggableGrid is also serialized using LayerDataConverter.  Within LayerDataConverter, this same process is done with all sprites on the layer with SpriteDataConverter.  All this serialized information about sprites and layers goes into the associated world XML file.  Serialization of worlds is therefore based on this hierarchy.

I think that this serialization process was a good decision.  Instead of saving every authoring environment in one single XML file, I decided to save every world separately.  In this way, we can potentially allow users to import or load only selected worlds from particular projects, instead of entire projects.  This design therefore leaves this project open to some more extension.  Also, instead of saving layers and sprites separately in GDH, I encapsulated that out into the more modular Map/Layer/SpriteDataConverters.  

There aren't really dangerous dependencies in this part of GDH because of the way the save method is accessed.  A DraggableGrid is the only thing that is needed, and because of how a DraggableGrid is constructed in MapManager, I know that it already must have an associated couple of Layers.  Because of how each Layer is constructed in DraggableGrid, I know that each of them must already have their own sprite managers initialized.  Therefore, saving grids/worlds depends on the fact that a/multiple DraggableGrid has been constructed with associated Layers and layer sprite managers, but this design is pretty fundamental to how the frontend and backend components of authoring are set up, so extremely unlikely to change.  

On the other hand, I encountered a few difficulties with loading/import that had more to do with dependencies within classes like DraggableGrid, MapManager, or the SpriteObjectGridManagers than my actual loading code or assumptions.  The loading process is that a user can choose to import/load a project, and this triggers GDH to find the local directory with this project name, find the world XML files, de-serialize these (in the process this de-serializes all the layers and sprites contained within layers too, since this logic is contained within the MapDataConverter and the LayerDataConverter), and then return a list of existing worlds to import that can be added on top of current worlds in the authoring environment.

This process took a lot of debugging, but basically, dependencies I encountered had to do with the fact that I could not properly associate predefined sprites with certain properties with certain layers without already having instances of separate classes such as SpriteGridHandler or MapLayer.  For example, I realized that a superclass and subclasses of MapLayer were needed for sprites to actually show up on a saved and loaded grid because this was the frontend component.  In order to fix errors like this, I tried to serialize by separating components out rather than composing them directly within a class that handles data.  For example, instead of placing saved sprites into their associated layers and returning those as I had previously done, I just added them to a "storedSprites" instance variable in each SpriteObjectGridManager class (that is associated with each layer).  Then, later, before utilizing these layers where MapLayers were initialized, I checked to see if the layer had anything in its storedSprites variable, and if so, I loaded those sprites in properly using a new MapLayer and if not, did nothing.  I did this process in DraggableGrid and the subclasses of SpriteObjectGridManager.  In this way, I left details of instantiation of new DraggableGrids and Layers out of the data storing and loading logic.  This may have been a bit of a bandaid solution, because there are still dependencies in authoring that caused these issues, but by the time I started working on data, these dependencies were so built in to authoring code that I had to prioritize and work with what I had.

Note: I hope this description and explanation made sense - there are a lot of similarly named classes that handle different but related things.  Another reason I think I continuously encountered new errors in authoring as a result of my attempts at loading, saving, and importing, is because the authoring design was definitely not very modular.  Since I joined the authoring team at the tail end of the first sprint, authoring people explained their code briefly to me, but I did not realize until I encountered errors what certain classes were responsible for or that all the information I needed was not centered in certain classes but very decentralized.  I definitely learned a lot about the importance of good design from the outset because of all the debugging I did.


### Flexibility

**Final Engine API** 

Even though I was mostly involved with authoring for the last half of the project, I will discuss the engine API because that's the one I was most involved with in design discussions and integration discussions.  

The primary engine API is EngineController, which is the main way the SpriteObjectGridToEngineController and Player (specifically the PlayerManager) interact with engine.  There are only a few methods that are offered, but they are all the most key ones -- starting and stopping the game, adding a new world, setting the next world, adding blueprints (which are factories for any of the objects that can be added to a game -- gameObjects, inventories, dialogue boxes, etc.), and a getter for the current world displayed.  This API definitely showcases simplicity and is powerful because it is very clear from all the methods what they are meant to do and how they should be used.  It is very good that there are only a few methods, because this forces any class that uses this API to encapsulate layer information into every world since layers cannot be separately passed.  Although all authoring objects are spriteObjects, there are some more specific classes in engine that define certain sprite/gameObjects as inventories or as having positionable or displayable images, so the addBlueprint method is very effective in leaving the details of this translation up to engine.  The addBlueprint method takes in a gameObjectFactory object (which is a blueprint), and this is made by using engine's convertToGameObject(AbstractSpriteObject) method. So, the end user (in this case SpriteObjectGridToEngineController) does not actually need to know what type of engine object they need to pass.  In this way, this design encourages encapsulation and abstraction. 

**Two Features I Did Not Implement**
One feature that I did not implement is the way that actions and conditions are set up in engine.  All gameObjects hold a map where conditions are keys and lists of actions are the values.  These actions are triggered when certain conditions are met.  These conditions and actions arise from an extremely comprehensive set of  actions classes.  I chose this code to discuss because we talked a lot about how our design of using actions and conditions made our program extremely flexible, and I was really impressed to see the sheer total number of possible combinations of conditions and actions available.

Actions classes function similarly to SLogo.  They are accessed via reflection, and properties files for every subpackage of actions are used to aid reflection.  Other than these properties files, nothing else is required for actions.  Of course, in order for any action to be activated, its associated condition must be true at one point.

Each action implements the Action interface, and has an execute method that takes in a GameObject (the object that the action should apply to), and GameMaster or a GameLayer.  Then, the action performs whatever it needs to do, such as performing a loop of other actions, moving a gameobject, rotating a gameobject, changing a gameobject or global variable, etc.  Assumptions that are made are that requested actions are always in existing properties files and that actions will always be triggered by a condition.  (Not that a condition could be something like "while true," but still, actions are triggered by conditions).  This set of classes are all extremely encapsulated because they implement an interface and an execute method in many different ways that are hidden from all other classes.  One minor issue is that the execute method takes in either a GameMaster or a GameLayer and to handle this, engine made a GameObjectEnvironment object that acts as either a GameMaster or a GameLayer and provides all the methods that actions classes might need from the two.  As engine documented in the GameObjectEnvironment class, this was a tradeoff decision they made to make sure actions had access to the methods/information they needed, but nothing more.  I think this was a good decision to properly encapsulate all other information about game layers and worlds that are not relevant and should not be used by actions.  Following this, actions are definitely really extensible.  Conditions and actions together are what provide ultimate flexibility for our overall program.  Many more actions can be added to update any gameObjects, worlds, and layers if needed. 

Another feature that I did not implement is the camera and parallax functionality implemented in engine.  I am writing about this feature because the final product of it looked really cool and using a camera to follow the movement of a character/object made our games much more smooth and professional.  A gameObject is required to implement this feature since the camera constructor takes in a gameObject.  I was surprised to find out how limited the code for this feature is considering it makes games look so much better.  The camera functionality is incredibly encapsulated and closed because all of the logic for it is done in one place.  It uses hard-coded values for screen-width, screen-height, and parallax in order to use the given game object to get the current x and y values and update them to take into account parallax.  Camera can handle following things like mouse clicks, which require the change in x and y values to be relative to the screen rather than the map, as well as following actual objects in the game, whose coordinates are not the same as the screen coordinates.

Assumptions that are made are obviously that there is a fixed screen width and height and desired parallax effect.  I don't think these are big issues, especially since the screen width and height are also fixed on the frontend of authoring, and that these numbers were chosen in order to maximize the design look.  The camera is also pretty flexible because it can follow any gameObject or even mouse clicks or mouse movement. 

However, I think the camera functionality could be more built into the engine hierarchy instead of really separate from it, because otherwise, this functionality could be easily done on the front end too.  It is not clear how it is integrated with the rest of engine.  This was a feature I know was added in the last couple of days, so I'm sure that's why.  Currently it is initialized in GameWorld and there is a method, drawWithParallax(Displayable) that basically uses the camera to change coordinates.  It would be better to allow users to choose what objects they want to have the effect and what objects they don't want to be included.  It would also be better to add in a method that allows the user to specify and change their desired parallax effect instead of having no options.

### Alternate Designs

The original API for engine, at least the EngineController one, did not change substantially except for the addition of the addBlueprint(GameObjectFactory) method.  The addition of this was very natural because we realized that we wanted to include many different types of more specific gameObjects with special properties like inventories.  GameObjects (SpriteObjects) in authoring did not specify this information, so this was left up to the engine.  On the other hand, authoring did not actually talk about APIs a lot, which is probably one of the reasons that we didn't think about or implement integration sooner.  There is a lot of shared information in authoring that we could have tried to encapsulate more.

**Design Discussions** 
In the very beginning, the engine team discussed how we wanted game objects to be able to perform actions and "react".  We iterated through the various possible options and talked about the pros and cons of each.  We talked about iterating through every game object every step and checking all the conditions associated with that object and then moving to triggered actions.  We talked about iterating through conditions first instead, and if a condition is true, then go to its associated game objects and triggering actions for them.  At first we talked about the potential inefficiency of iterating through all game objects every step, but then put that aside as we knew this class isn't focused on efficiency.  We discussed checking conditions first seriously, but ultimately decided to go with the check every gameObject first model because we thought about use cases.  For example, if a user wanted certain conditions and actions to be prioritized for certain gameObjects but different prioritization schemes for other game objects, then we needed a way to handle that, and iterating through conditions would not enable that.  Another issue that we discussed in the same design discussion is how to allow actions to perform operations that involve more than just the game object they are applied on.  For example, having something happen because of a collision with another game object, or performing an action that impacts another game object.  We decided that to incorporate this, we would need every execute method of the actions to take in a game world or game layer (abstracted in game object environment as discussed above).  The con of this decision is that it potentially exposes a lot of information via methods to every action, but this risk was mitigated by the creation of the GameObjectEnvironment class that provides access to only the methods that are necessary.   I definitely think that this design for triggering actions and conditions was a good idea because of the reasons discussed above.  This design provides the most flexibility to the user because every single game object can have lots of unique conditions and actions, as well as unique condition-action prioritization schemes.

Another design discussion we had was basically about how to refactor authoring to allow sharing of certain grid and sprite information.  We did not discuss this in too much detail unfortunately.  We decided to handle this sharing of information by passing the AuthoringEnvironmentManager to all the managers (discussed at the very beginning) instead of accessing information in a more convoluted, hidden way.  AEM handles all the possible sprites and is passed around because in every different tab we want the user to have access to the sprites that they have created or are using.  Alternate designs discussed were to just pass the relevant information instead of AEM.  Looking back, I think both of these design options are not great.  The biggest, most fundamental issue I see here is that every manager that gets passed AEM uses it to get GameDataHandler to have access to all the data and images it might need.  GameDataHandler basically has been elevated to global status in our program because of the way it's accessed, which is really not ideal since this means that all data can be accessed by any class in authoring, even data that is not relevant to the class.  It is convenient because stored data, particularly images, need to be accessed quite a lot in various tabs/managers.  The first thing I would propose is to break down GameDataHandler into its various components since it does a lot of different things (all data related) right now.  I would separate out the serialization and de-serialization of engine data into another class.  I would also remove sprite image saving and loading into another class.  Then, all that is left in GameDataHandler would mostly be saving, loading, and importing worlds and layers.  In this way, instead of giving everyone access to GameDataHandler, we could only give access to the class for handling sprite-specific data, since this is what is needed frequently by many classes.  I think that this simple change would reduce exposure of GameDataHandler by a lot, thankfully, and would still provide classes access to the image and sprite data they need.  

### Conclusions

I think that the best feature of the project's current design is the hierarchy in both engine and authoring of game worlds, which contain layers, which contain game objects.  The implementation of this design layout is certainly not as clean in authoring as in engine, but it still provides an excellent skeleton structure to organize a program in.  I really like how flexible this basic composition hierarchy makes our overall design.  After SLogo, when I tried implementing composition but ended up doing this strange mixture of inheritance and composition instead, I had a basic understanding of composition and thought it was interesting, but I really solidified my understanding during this project and really appreciate that.  I now understand the tradeoffs between composition and inheritance more because I've directly been involved in the implementation, and I think composition is a really cool and elegant way of defining extremely flexible objects.

The worst feature that remains in the project's current design is definitely integration of authoring.  Things are functional enough, but it was extremely difficult to integrate various parts of authoring (basically the different managers' responsibilities - sprite creation, dialogue creation, cut scene creation, heads up display creation, and the overall map manager) seamlessly.  I am glad that I spent some time on the engine team and some time on the authoring team handling refactoring and data because that allows me to compare the two design processes.  I learned how important and essential it is to deeply define design at the very beginning by considering as many different use cases as possible and thinking about how to handle integration directly.  On the same note, thinking about how to store data early on in the process is really important as well.
